# 罪語者 (Verbal Sinner) - 技術架構設計

## 架構概述

### 技術選型原則
- **快速開發**：適合 6 天衝刺的技術棧
- **可擴展性**：支持後續功能擴展
- **成本效益**：初期低成本，後續可擴展
- **性能優先**：確保流暢的遊戲體驗
- **模組化設計**：各系統獨立，易於維護

### 整體架構

```
┌─────────────────────────────────────────┐
│           前端 (Frontend)               │
│  React + TypeScript + Vite              │
│  - 遊戲界面                              │
│  - 對話系統                              │
│  - 狀態管理 (Zustand)                    │
│  - 動畫系統 (Framer Motion)              │
└──────────────┬──────────────────────────┘
               │ HTTP/WebSocket
┌──────────────▼──────────────────────────┐
│         API Gateway / CDN               │
│  Vercel / Cloudflare                    │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│        後端服務 (Backend)                │
│  Node.js + Express / Fastify            │
│  - RESTful API                           │
│  - WebSocket (實時對話)                   │
│  - 遊戲邏輯處理                           │
│  - AI 對話整合                           │
└──────────────┬──────────────────────────┘
               │
    ┌──────────┴──────────┐
    │                      │
┌───▼────┐          ┌─────▼────┐
│ 資料庫  │          │  快取層   │
│PostgreSQL│          │  Redis   │
│  /      │          │          │
│Supabase │          │          │
└─────────┘          └──────────┘
```

---

## 前端架構

### 技術棧

#### 核心框架
- **React 18+**：組件化開發
- **TypeScript**：類型安全
- **Vite**：快速開發和構建

#### 狀態管理
- **Zustand**：輕量級狀態管理
  - 遊戲進度狀態
  - 對話狀態
  - 情緒系統狀態
  - UI 狀態

#### UI 框架
- **Tailwind CSS**：快速樣式開發
- **Framer Motion**：動畫和過渡效果
- **React Router**：路由管理

#### 工具庫
- **React Query**：數據獲取和緩存
- **Zod**：數據驗證
- **date-fns**：時間處理
- **react-player**（可選）：影片播放器組件（如果需要更多功能）

### 專案結構

```
frontend/
├── src/
│   ├── components/          # 可重用組件
│   │   ├── ui/              # 基礎 UI 組件
│   │   ├── game/            # 遊戲專用組件
│   │   │   ├── DialogueBox.tsx
│   │   │   ├── EmotionMeter.tsx
│   │   │   ├── ChallengeCard.tsx
│   │   │   └── ProgressBar.tsx
│   │   └── layout/          # 布局組件
│   ├── pages/               # 頁面組件
│   │   ├── ProloguePage.tsx      # 前情提要（影片播放）
│   │   ├── RevivalPage.tsx        # 復活機制
│   │   ├── ChallengePage.tsx     # 挑戰頁面
│   │   └── DialoguePage.tsx      # 對話頁面
│   ├── stores/              # Zustand stores
│   │   ├── gameStore.ts     # 遊戲狀態
│   │   ├── dialogueStore.ts # 對話狀態
│   │   ├── emotionStore.ts  # 情緒狀態
│   │   └── progressStore.ts # 進度狀態
│   ├── services/            # API 服務
│   │   ├── api.ts           # API 客戶端
│   │   ├── dialogueService.ts  # 對話服務
│   │   └── challengeService.ts # 挑戰服務
│   ├── hooks/               # 自定義 Hooks
│   │   ├── useDialogue.ts
│   │   ├── useEmotion.ts
│   │   └── useChallenge.ts
│   ├── utils/               # 工具函數
│   │   ├── emotionUtils.ts
│   │   ├── validation.ts
│   │   └── constants.ts
│   ├── types/               # TypeScript 類型
│   │   ├── game.ts
│   │   ├── dialogue.ts
│   │   └── emotion.ts
│   └── App.tsx
├── public/                  # 靜態資源
│   ├── videos/
│   │   └── prologue.mp4     # 前情提要影片
│   ├── images/
│   ├── audio/
│   └── fonts/
└── package.json
```

### 核心組件設計

#### 1. 遊戲狀態管理 (gameStore.ts)

```typescript
interface GameState {
  // 遊戲階段
  phase: 'prologue' | 'revival' | 'challenge' | 'ending'
  
  // 前情提要狀態
  prologue: {
    hasWatched: boolean // 是否已觀看前情提要影片
    videoUrl: string // 影片 URL
  }
  
  // 進度追蹤
  currentChallengeId: number | null
  completedChallenges: number[]
  totalProgress: number // 0-20
  
  // 角色關係狀態
  relationships: {
    [characterId: string]: {
      emotion: EmotionType
      opinion: number // -100 to 100
    }
  }
  
  // 遊戲設定
  settings: {
    soundEnabled: boolean
    autoSave: boolean
  }
}
```

#### 2. 對話系統 (DialogueBox.tsx)

```typescript
interface DialogueState {
  currentDialogue: {
    npcId: string
    npcMessage: string
    playerOptions: DialogueOption[]
    currentRound: number
    maxRounds: number
  }
  
  dialogueHistory: DialogueEntry[]
  
  // 情緒追蹤
  emotionState: {
    current: EmotionType
    target: EmotionType
    progress: number // 0-100
  }
}
```

#### 3. 前情提要影片播放 (ProloguePage.tsx)

```typescript
interface ProloguePageProps {
  videoUrl: string
  onComplete: () => void // 影片播放完成後的回調
  onSkip?: () => void // 可選：跳過功能
}

// 使用 HTML5 video 或 react-player
// 功能：
// - 全螢幕播放
// - 自動播放
// - 播放完成後自動進入下一階段
// - 可選：暫停、進度條、跳過功能
```

#### 4. 情緒系統 (EmotionMeter.tsx)

```typescript
type EmotionType = 
  | '冷漠' | '困惑'
  | '好感' | '欣賞' | '尊重' | '愧疚' | '認同'
  | '憤怒' | '震驚' | '崩潰' | '慌張'

interface EmotionState {
  type: EmotionType
  intensity: number // 0-100
  trend: 'up' | 'down' | 'stable'
}
```

### 前端性能優化

1. **代碼分割**
   - 路由級別代碼分割
   - 組件級別延遲載入
   - 動態導入大型資源

2. **資源優化**
   - 影片使用 H.264 編碼，適當壓縮（平衡品質與檔案大小）
   - 圖片使用 WebP 格式
   - 音頻使用壓縮格式（影片音軌已嵌入，無需額外載入）
   - 字體子集化
   - 影片預載入策略（可選：預載入或按需載入）

3. **狀態優化**
   - 使用 React.memo 避免不必要的重渲染
   - 使用 useMemo 和 useCallback 優化計算
   - 虛擬化長列表

4. **緩存策略**
   - React Query 自動緩存 API 響應
   - Service Worker 緩存靜態資源（包含影片）
   - LocalStorage 緩存遊戲進度
   - 影片緩存：使用瀏覽器緩存或 Service Worker 緩存影片檔案

---

## 後端架構

### 技術棧

#### 核心框架
- **Node.js 20+**：運行環境
- **Express / Fastify**：Web 框架
- **TypeScript**：類型安全

#### 數據庫
- **PostgreSQL**（主數據庫）
  - 或使用 **Supabase**（PostgreSQL + 即時功能）
- **Redis**（緩存和會話）

#### AI 整合
- **OpenAI API** / **Anthropic Claude**：對話生成
- **Google Gemini**：備選方案

> MVP（目前 repo 實作建議）：用 **Firebase Cloud Functions** 提供 `generateNpcReply` callable，前端只呼叫自家 Functions（API key 不下放到前端）。  
> Provider 可切換 OpenAI / Gemini；輸出統一 JSON：`{ npc_reply, npc_emotion_hint, notes }`，方便接回情緒/屬性系統。

#### 其他服務
- **WebSocket** (Socket.io)：實時對話
- **JWT**：身份驗證
- **Zod**：數據驗證

### API 設計

#### RESTful API 端點

```
# 遊戲進度
GET    /api/game/progress          # 獲取遊戲進度
POST   /api/game/progress          # 更新遊戲進度
GET    /api/game/challenges        # 獲取挑戰列表
GET    /api/game/challenges/:id    # 獲取特定挑戰

# 對話系統
POST   /api/dialogue/start         # 開始對話
POST   /api/dialogue/respond       # 玩家回應
GET    /api/dialogue/status/:id    # 獲取對話狀態

# 情緒系統
GET    /api/emotion/:npcId         # 獲取 NPC 情緒
POST   /api/emotion/update         # 更新情緒狀態

# 復活機制
POST   /api/revival/initiate       # 觸發復活
POST   /api/revival/verify-ad      # 驗證廣告完成

# 用戶管理
POST   /api/auth/register          # 註冊
POST   /api/auth/login             # 登入
GET    /api/auth/me                # 獲取當前用戶
```

#### WebSocket 事件

```typescript
// 客戶端 → 服務器
'send-message': { challengeId, optionId, message }
'request-dialogue': { challengeId }
'update-emotion': { npcId, emotionType }

// 服務器 → 客戶端
'dialogue-response': { npcMessage, options, emotionUpdate }
'emotion-changed': { npcId, emotionType, intensity }
'challenge-completed': { challengeId, rewards }
```

### 數據庫設計

#### 核心表結構

```sql
-- 用戶表
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  username VARCHAR(100),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 遊戲進度表
CREATE TABLE game_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  current_phase VARCHAR(50) NOT NULL,
  current_challenge_id INTEGER,
  total_progress INTEGER DEFAULT 0,
  completed_challenges INTEGER[] DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id)
);

-- 挑戰表（靜態數據）
CREATE TABLE challenges (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  category VARCHAR(50) NOT NULL, -- '職場' | '朋友' | '情人' | '自我'
  difficulty VARCHAR(20) NOT NULL, -- '簡單' | '中等' | '困難'
  max_rounds INTEGER NOT NULL,
  target_emotion VARCHAR(50) NOT NULL,
  npc_id INTEGER REFERENCES npcs(id),
  story_date DATE NOT NULL,
  metadata JSONB
);

-- NPC 表（靜態數據）
CREATE TABLE npcs (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  role VARCHAR(50) NOT NULL, -- '職場' | '朋友' | '情人' | '家人'
  description TEXT,
  avatar_url VARCHAR(500),
  initial_emotion VARCHAR(50) DEFAULT '冷漠',
  metadata JSONB
);

-- 對話選項表（靜態數據）
CREATE TABLE dialogue_options (
  id SERIAL PRIMARY KEY,
  challenge_id INTEGER REFERENCES challenges(id),
  round_number INTEGER NOT NULL,
  option_text TEXT NOT NULL,
  option_type VARCHAR(50) NOT NULL, -- '積極對抗' | '溫和堅持' | '情感訴求' | '順從消極'
  emotion_impact JSONB, -- { emotionType: delta }
  next_round INTEGER,
  metadata JSONB
);

-- 對話記錄表
CREATE TABLE dialogue_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  challenge_id INTEGER REFERENCES challenges(id),
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  status VARCHAR(20) DEFAULT 'active', -- 'active' | 'completed' | 'failed'
  rounds_completed INTEGER DEFAULT 0,
  final_emotion VARCHAR(50),
  dialogue_history JSONB
);

-- 情緒狀態表
CREATE TABLE emotion_states (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  npc_id INTEGER REFERENCES npcs(id),
  current_emotion VARCHAR(50) NOT NULL,
  intensity INTEGER DEFAULT 0, -- 0-100
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id, npc_id)
);

-- 關係狀態表
CREATE TABLE relationships (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  npc_id INTEGER REFERENCES npcs(id),
  opinion_score INTEGER DEFAULT 0, -- -100 to 100
  last_interaction TIMESTAMP,
  metadata JSONB,
  UNIQUE(user_id, npc_id)
);
```

#### 索引優化

```sql
-- 性能優化索引
CREATE INDEX idx_game_progress_user ON game_progress(user_id);
CREATE INDEX idx_dialogue_sessions_user ON dialogue_sessions(user_id);
CREATE INDEX idx_dialogue_sessions_challenge ON dialogue_sessions(challenge_id);
CREATE INDEX idx_emotion_states_user_npc ON emotion_states(user_id, npc_id);
CREATE INDEX idx_relationships_user_npc ON relationships(user_id, npc_id);
```

### 遊戲邏輯服務

#### 對話系統服務 (dialogueService.ts)

```typescript
class DialogueService {
  // 開始對話
  async startDialogue(userId: string, challengeId: number) {
    // 1. 獲取挑戰配置
    // 2. 初始化 NPC 情緒狀態
    // 3. 生成初始對話
    // 4. 返回對話選項
  }
  
  // 處理玩家回應
  async processResponse(
    sessionId: string, 
    optionId: number
  ) {
    // 1. 驗證選項有效性
    // 2. 計算情緒變化
    // 3. 生成 NPC 回應（AI 或預設）
    // 4. 檢查是否達成目標
    // 5. 返回結果
  }
  
  // 生成 NPC 回應（AI 整合）
  async generateNPCResponse(
    npcId: number,
    playerMessage: string,
    currentEmotion: EmotionType,
    context: DialogueContext
  ) {
    // 調用 AI API 生成回應
    // 確保回應符合 NPC 性格和當前情緒
  }
}
```

#### 情緒系統服務 (emotionService.ts)

```typescript
class EmotionService {
  // 更新情緒狀態
  async updateEmotion(
    userId: string,
    npcId: number,
    emotionDelta: EmotionDelta
  ) {
    // 1. 獲取當前情緒
    // 2. 計算新情緒
    // 3. 應用情緒轉化規則
    // 4. 更新數據庫
    // 5. 檢查是否達成目標
  }
  
  // 情緒轉化邏輯
  calculateEmotionTransition(
    current: EmotionType,
    delta: EmotionDelta
  ): EmotionType {
    // 實現情緒轉化路徑邏輯
    // 例如：冷漠 → 震驚 → 愧疚 → 尊重
  }
  
  // 檢查目標達成
  checkTargetAchieved(
    current: EmotionType,
    target: EmotionType
  ): boolean {
    // 檢查是否達成目標情緒
  }
}
```

#### 挑戰系統服務 (challengeService.ts)

```typescript
class ChallengeService {
  // 獲取挑戰列表
  async getChallenges(userId: string) {
    // 返回所有挑戰，標記完成狀態
  }
  
  // 完成挑戰
  async completeChallenge(
    userId: string,
    challengeId: number
  ) {
    // 1. 驗證挑戰完成條件
    // 2. 更新進度
    // 3. 更新關係狀態
    // 4. 觸發獎勵
    // 5. 檢查是否完成所有挑戰
  }
  
  // 獲取進度統計
  async getProgress(userId: string) {
    // 返回詳細進度信息
  }
}
```

### AI 對話整合

#### AI 服務封裝 (aiService.ts)

```typescript
class AIService {
  // 生成 NPC 回應
  async generateDialogueResponse(
    npc: NPC,
    playerMessage: string,
    context: DialogueContext
  ): Promise<string> {
    const prompt = this.buildPrompt(npc, playerMessage, context);
    
    // 使用 OpenAI 或 Claude
    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: this.buildSystemPrompt(npc, context)
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 200
    });
    
    return response.choices[0].message.content;
  }
  
  // 構建系統提示
  private buildSystemPrompt(npc: NPC, context: DialogueContext): string {
    return `
你是一個對話遊戲中的 NPC 角色。
角色名稱：${npc.name}
角色性格：${npc.description}
當前情緒：${context.currentEmotion}
目標情緒：${context.targetEmotion}
對話回合：${context.currentRound}/${context.maxRounds}

請根據角色性格和當前情緒，生成符合情境的回應。
回應應該：
1. 符合角色性格
2. 反映當前情緒狀態
3. 推動對話向目標情緒發展
4. 簡潔有力（不超過 50 字）
    `;
  }
}
```

### 緩存策略

#### Redis 緩存設計

```typescript
// 緩存鍵設計
const CacheKeys = {
  // 用戶進度
  userProgress: (userId: string) => `progress:${userId}`,
  
  // 挑戰數據
  challenge: (challengeId: number) => `challenge:${challengeId}`,
  
  // NPC 數據
  npc: (npcId: number) => `npc:${npcId}`,
  
  // 情緒狀態
  emotion: (userId: string, npcId: number) => 
    `emotion:${userId}:${npcId}`,
  
  // AI 對話緩存（避免重複調用）
  aiResponse: (hash: string) => `ai:${hash}`
};

// 緩存 TTL
const CacheTTL = {
  userProgress: 3600, // 1 小時
  challenge: 86400,    // 24 小時（靜態數據）
  npc: 86400,          // 24 小時
  emotion: 1800,       // 30 分鐘
  aiResponse: 3600     // 1 小時
};
```

---

## 部署架構

### 前端部署

#### 方案一：Vercel（推薦）
- **優點**：自動部署、CDN、免費額度
- **配置**：連接 GitHub，自動部署
- **環境變數**：API 端點、環境配置

#### 方案二：Netlify
- **優點**：類似 Vercel，支持預渲染
- **適用**：需要更好的 SEO

#### 方案三：Cloudflare Pages
- **優點**：全球 CDN、低延遲
- **適用**：重視性能

### 後端部署

#### 方案一：Vercel Serverless Functions
- **優點**：與前端同平台、自動擴展
- **限制**：函數執行時間限制
- **適用**：初期 MVP

#### 方案二：Railway / Render
- **優點**：簡單部署、自動擴展
- **適用**：需要持久連接（WebSocket）

#### 方案三：AWS / GCP / Azure
- **優點**：完整控制、高可擴展性
- **適用**：後期擴展

### 數據庫部署

#### 方案一：Supabase（推薦初期）
- **優點**：PostgreSQL + 即時功能、免費額度
- **功能**：認證、實時訂閱、存儲

#### 方案二：Railway PostgreSQL
- **優點**：簡單、可擴展
- **適用**：需要獨立數據庫

#### 方案三：AWS RDS / Google Cloud SQL
- **優點**：企業級、高可用
- **適用**：後期擴展

### Redis 部署

#### 方案一：Upstash（推薦）
- **優點**：Serverless Redis、按需付費
- **適用**：初期低成本

#### 方案二：Railway Redis
- **優點**：簡單部署
- **適用**：需要持久 Redis

---

## 開發流程

### 階段一：基礎架構（Day 1-2）

1. **專案初始化**
   - 設置前端專案（React + Vite + TypeScript）
   - 設置後端專案（Node.js + Express + TypeScript）
   - 配置數據庫（Supabase 或 PostgreSQL）
   - 設置 Redis（Upstash）

2. **基礎組件**
   - 實現路由系統
   - 實現基礎 UI 組件
   - 實現狀態管理（Zustand）
   - 實現 API 客戶端

3. **數據庫設計**
   - 創建數據表
   - 設置索引
   - 創建初始數據（挑戰、NPC）

### 階段二：核心功能（Day 3-4）

1. **前情提要系統**
   - 實現前情提要影片播放頁面
   - 整合影片播放器組件（HTML5 video 或第三方播放器）
   - 實現影片播放控制（播放、暫停、進度條）
   - 影片播放完成後進入復活機制

2. **復活機制**
   - 實現復活決定頁面
   - 整合廣告 SDK（Google AdSense 或類似）
   - 實現時空轉換動畫
   - 實現系統說明頁面

3. **挑戰系統**
   - 實現挑戰列表頁面
   - 實現挑戰卡片組件
   - 實現進度追蹤

### 階段三：對話系統（Day 5-6）

1. **對話界面**
   - 實現對話框組件
   - 實現選項按鈕
  - 實現輪次計數器

2. **情緒系統**
   - 實現情緒顯示組件
   - 實現情緒變化動畫
   - 實現情緒轉化邏輯

3. **AI 整合**
   - 整合 AI API（OpenAI / Claude）
   - 實現對話生成邏輯
   - 實現情緒判定

4. **完成流程**
   - 實現挑戰完成判定
   - 實現進度更新
   - 實現結局頁面

### 測試與優化

1. **功能測試**
   - 測試所有遊戲流程
   - 測試對話系統
   - 測試情緒系統

2. **性能優化**
   - 優化前端渲染
   - 優化 API 響應
   - 優化數據庫查詢

3. **部署**
   - 部署前端到 Vercel
   - 部署後端到 Railway
   - 配置環境變數
   - 測試生產環境

---

## 技術決策說明

### 為什麼選擇 React？
- **生態系統豐富**：大量組件庫和工具
- **開發效率高**：組件化開發，快速迭代
- **性能優秀**：React 18 的並發特性
- **團隊熟悉度**：學習曲線低

### 為什麼選擇 Zustand？
- **輕量級**：比 Redux 簡單，比 Context 強大
- **TypeScript 友好**：類型推斷優秀
- **性能好**：選擇性訂閱，避免不必要的重渲染
- **適合遊戲狀態**：簡單的狀態管理需求

### 為什麼選擇 PostgreSQL？
- **關係型數據**：遊戲數據有明確關係
- **JSONB 支持**：靈活存儲對話歷史等
- **成熟穩定**：生產環境驗證
- **Supabase 整合**：快速開發

### 為什麼選擇 Supabase？
- **快速開發**：內建認證、實時功能
- **免費額度**：初期成本低
- **PostgreSQL**：標準 SQL，易於遷移
- **即時訂閱**：可實現實時更新

### 為什麼選擇 Vercel？
- **零配置部署**：連接 GitHub 自動部署
- **全球 CDN**：低延遲訪問
- **Serverless Functions**：後端 API 可同平台
- **免費額度**：初期足夠使用

---

## 後續擴展計劃

### 短期擴展（1-2 個月）

1. **用戶系統**
   - 用戶註冊/登入
   - 進度雲端同步
   - 多設備支持

2. **社交功能**
   - 分享挑戰結果
   - 排行榜
   - 成就系統

3. **內容擴展**
   - 更多挑戰關卡
   - 分支劇情
   - 多結局系統

### 中期擴展（3-6 個月）

1. **付費機制**
   - 跳過廣告
   - 解鎖額外內容
   - 訂閱制

2. **AI 增強**
   - 更智能的對話生成
   - 個性化劇情
   - 動態難度調整

3. **多語言支持**
   - 國際化
   - 多語言對話

### 長期擴展（6 個月+）

1. **移動應用**
   - React Native 版本
   - 原生體驗優化

2. **多人模式**
   - 協作挑戰
   - 對戰模式

3. **內容創作工具**
   - 用戶自創挑戰
   - 社區分享

---

## 安全考量

### 前端安全
- **輸入驗證**：所有用戶輸入驗證
- **XSS 防護**：React 自動轉義
- **CSRF 防護**：使用 SameSite Cookie

### 後端安全
- **身份驗證**：JWT Token
- **API 限流**：防止濫用
- **數據驗證**：Zod 驗證所有輸入
- **SQL 注入防護**：使用參數化查詢

### 數據安全
- **加密傳輸**：HTTPS
- **敏感數據加密**：數據庫加密
- **隱私保護**：符合 GDPR

---

## 監控與日誌

### 前端監控
- **錯誤追蹤**：Sentry
- **性能監控**：Web Vitals
- **用戶行為**：Google Analytics

### 後端監控
- **API 監控**：Uptime Robot
- **錯誤日誌**：Winston + Sentry
- **性能監控**：APM 工具

### 數據庫監控
- **查詢性能**：慢查詢日誌
- **連接池監控**：連接數監控
- **備份策略**：自動備份

---

## 成本估算

### 初期成本（月）

| 服務 | 方案 | 月成本 |
|------|------|--------|
| 前端部署 | Vercel (免費) | $0 |
| 後端部署 | Railway (免費額度) | $0-5 |
| 數據庫 | Supabase (免費) | $0 |
| Redis | Upstash (免費額度) | $0 |
| AI API | OpenAI (按量) | $10-50 |
| **總計** | | **$10-55/月** |

### 擴展後成本（1000+ 用戶）

| 服務 | 方案 | 月成本 |
|------|------|--------|
| 前端部署 | Vercel Pro | $20 |
| 後端部署 | Railway | $20-50 |
| 數據庫 | Supabase Pro | $25 |
| Redis | Upstash | $10-20 |
| AI API | OpenAI | $100-500 |
| CDN | Cloudflare | $0-20 |
| **總計** | | **$175-615/月** |

---

## 總結

這個技術架構設計：

1. **適合快速開發**：使用成熟的技術棧，快速迭代
2. **成本可控**：初期幾乎零成本，後續按需擴展
3. **可擴展性強**：模組化設計，易於添加新功能
4. **性能優秀**：前端優化 + 後端緩存，確保流暢體驗
5. **易於維護**：清晰的代碼結構，完善的文檔

建議按照階段逐步實施，先實現核心功能，再逐步完善和優化。

